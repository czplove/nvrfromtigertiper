/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h>		/* for memset */
#include "nvr.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

u_int *
nvrproc_open_1(CMMNargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_OPEN, (xdrproc_t) xdr_CMMNargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_close_1(u_int * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_CLOSE, (xdrproc_t) xdr_u_int, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

READres *
nvrproc_read_1(READargs * argp, CLIENT * clnt)
{
	static READres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_READ, (xdrproc_t) xdr_READargs, (caddr_t) argp, (xdrproc_t) xdr_READres, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_write_1(WRITEargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_WRITE, (xdrproc_t) xdr_WRITEargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

HEADERinfo *
nvrproc_getheader_1(CMMNargs * argp, CLIENT * clnt)
{
	static HEADERinfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_GETHEADER,
		      (xdrproc_t) xdr_CMMNargs, (caddr_t) argp, (xdrproc_t) xdr_HEADERinfo, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_create_1(CREATEargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_CREATE, (xdrproc_t) xdr_CREATEargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

SEARCHres *
nvrproc_searchrecord_1(SEARCHargs * argp, CLIENT * clnt)
{
	static SEARCHres clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_SEARCHRECORD,
		      (xdrproc_t) xdr_SEARCHargs, (caddr_t) argp, (xdrproc_t) xdr_SEARCHres, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_setrecinfo_1(SETRECINFOargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_SETRECINFO,
		      (xdrproc_t) xdr_SETRECINFOargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

VOLUMinfo *
nvrproc_getvolumeinfo_1(u_int * argp, CLIENT * clnt)
{
	static VOLUMinfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_GETVOLUMEINFO,
		      (xdrproc_t) xdr_u_int, (caddr_t) argp, (xdrproc_t) xdr_VOLUMinfo, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_delete_1(DELargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_DELETE, (xdrproc_t) xdr_DELargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_int *
nvrproc_login_1(LOGINargs * argp, CLIENT * clnt)
{
	static u_int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_LOGIN, (xdrproc_t) xdr_LOGINargs, (caddr_t) argp, (xdrproc_t) xdr_u_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nvrproc_logout_1(u_int * argp, CLIENT * clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_LOGOUT, (xdrproc_t) xdr_u_int, (caddr_t) argp, (xdrproc_t) xdr_int, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

u_long *
nvrproc_getlasterror_1(void *argp, CLIENT * clnt)
{
	static u_long clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, NVRPROC_GETLASTERROR, (xdrproc_t) xdr_void, (caddr_t) argp, (xdrproc_t) xdr_u_long, (caddr_t) & clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
